#include <ParagonMQTT.h>
#include <FastLED.h>

const char *deviceID = "Syringe"; // CHANGE deviceID TO THE NAME YOU WANT THIS TEENSY TO BE IDENTIFIED
const char *roomID = "Clockwork";

const byte POWERLED = 13;

// LED Settings
const byte LEDRINGA = 24;
const byte LEDRINGB = 25;
const byte LEDRINGC = 26;
const byte LEDRINGD = 27;
const byte LEDRINGE = 28;
const byte LEDRINGF = 29;
const byte LEDFILAMENT = 30;
const int NUM_LEDS = 12;

const byte FORGEACTUATORRETRACT = 31;
const byte FORGEACTUATOREXTEND = 32;

// Rotary Encoder Pin Definitions
const byte ROTARY_LT_A = 18;
const byte ROTARY_LT_B = 19;
const byte ROTARY_LM_A = 16;
const byte ROTARY_LM_B = 17;
const byte ROTARY_LB_A = 14;
const byte ROTARY_LB_B = 15;
const byte ROTARY_RT_A = 20;
const byte ROTARY_RT_B = 21;
const byte ROTARY_RM_A = 40;
const byte ROTARY_RM_B = 41;
const byte ROTARY_RB_A = 22;
const byte ROTARY_RB_B = 23;

const byte ACTUATORS_UP = 33;
const byte ACTUATORS_DN = 34;

CRGB ringA[NUM_LEDS];
CRGB ringB[NUM_LEDS];
CRGB ringC[NUM_LEDS];
CRGB ringD[NUM_LEDS];
CRGB ringE[NUM_LEDS];
CRGB ringF[NUM_LEDS];

volatile long encoderValues[6] = {0}; // Store values for all 6 encoders
int lastEncoded[6] = {0};             // To store last encoded values for all encoders
char encoderDebug[100];
char message[200]; // Buffer for MQTT message

void setup()
{
  Serial.begin(115200);

  FastLED.addLeds<WS2812B, LEDRINGA, GRB>(ringA, NUM_LEDS);
  FastLED.addLeds<WS2812B, LEDRINGB, GRB>(ringB, NUM_LEDS);
  FastLED.addLeds<WS2812B, LEDRINGC, GRB>(ringC, NUM_LEDS);
  FastLED.addLeds<WS2812B, LEDRINGD, GRB>(ringD, NUM_LEDS);
  FastLED.addLeds<WS2812B, LEDRINGE, GRB>(ringE, NUM_LEDS);
  FastLED.addLeds<WS2812B, LEDRINGF, GRB>(ringF, NUM_LEDS);

  // Setup pin modes for all encoder pins
  pinMode(ROTARY_LT_A, INPUT_PULLUP);
  pinMode(ROTARY_LT_B, INPUT_PULLUP);
  pinMode(ROTARY_LM_A, INPUT_PULLUP);
  pinMode(ROTARY_LM_B, INPUT_PULLUP);
  pinMode(ROTARY_LB_A, INPUT_PULLUP);
  pinMode(ROTARY_LB_B, INPUT_PULLUP);
  pinMode(ROTARY_RT_A, INPUT_PULLUP);
  pinMode(ROTARY_RT_B, INPUT_PULLUP);
  pinMode(ROTARY_RM_A, INPUT_PULLUP);
  pinMode(ROTARY_RM_B, INPUT_PULLUP);
  pinMode(ROTARY_RB_A, INPUT_PULLUP);
  pinMode(ROTARY_RB_B, INPUT_PULLUP);

  // Attach interrupts for all encoder pairs
  attachInterrupt(ROTARY_LT_A, updateEncoderLT, CHANGE);
  attachInterrupt(ROTARY_LT_B, updateEncoderLT, CHANGE);
  attachInterrupt(ROTARY_LM_A, updateEncoderLM, CHANGE);
  attachInterrupt(ROTARY_LM_B, updateEncoderLM, CHANGE);
  attachInterrupt(ROTARY_LB_A, updateEncoderLB, CHANGE);
  attachInterrupt(ROTARY_LB_B, updateEncoderLB, CHANGE);
  attachInterrupt(ROTARY_RT_A, updateEncoderRT, CHANGE);
  attachInterrupt(ROTARY_RT_B, updateEncoderRT, CHANGE);
  attachInterrupt(ROTARY_RM_A, updateEncoderRM, CHANGE);
  attachInterrupt(ROTARY_RM_B, updateEncoderRM, CHANGE);
  attachInterrupt(ROTARY_RB_A, updateEncoderRB, CHANGE);
  attachInterrupt(ROTARY_RB_B, updateEncoderRB, CHANGE);

  // Onboard LED for power status
  pinMode(POWERLED, OUTPUT);
  pinMode(ACTUATORS_UP, OUTPUT);
  pinMode(ACTUATORS_DN, OUTPUT);
  digitalWrite(POWERLED, HIGH);
  digitalWrite(ACTUATORS_UP, HIGH);
  digitalWrite(ACTUATORS_DN, LOW);
  pinMode(LEDFILAMENT, OUTPUT);
  digitalWrite(LEDFILAMENT, HIGH);
  pinMode(FORGEACTUATOREXTEND, OUTPUT);
  pinMode(FORGEACTUATORRETRACT, OUTPUT);
  digitalWrite(FORGEACTUATOREXTEND, LOW);
  digitalWrite(FORGEACTUATORRETRACT, HIGH);

  registerAction("actuators", actuators);

  // Setup the ethernet network connection
  networkSetup();
  // Setup the MQTT service
  mqttSetup();

  fill_solid(ringA, NUM_LEDS, CRGB::Blue);
  fill_solid(ringB, NUM_LEDS, CRGB::Red);
  fill_solid(ringC, NUM_LEDS, CRGB::Yellow);
  fill_solid(ringD, NUM_LEDS, CRGB::Green);
  fill_solid(ringE, NUM_LEDS, CRGB::Purple);
  fill_solid(ringF, NUM_LEDS, CRGB::Orange);

  FastLED.show();
}

void loop()
{
  sendDataMQTT();

  // Continuously check the encoder values
  checkEncoderValues();

  sprintf(publishDetail,
          "%ld,%ld,%ld,%ld,%ld,%ld",
          encoderValues[0], encoderValues[1], encoderValues[2],
          encoderValues[3], encoderValues[4], encoderValues[5]);
}

// Function to continuously check encoder values
void checkEncoderValues()
{
  // This function can be expanded if you want to perform some processing on encoder values
  // For now, it just reads values (which are updated in the interrupt functions)
}

void updateEncoderLT()
{
  updateEncoder(0, ROTARY_LT_A, ROTARY_LT_B);
}
void updateEncoderLM()
{
  updateEncoder(1, ROTARY_LM_A, ROTARY_LM_B);
}
void updateEncoderLB()
{
  updateEncoder(2, ROTARY_LB_A, ROTARY_LB_B);
}
void updateEncoderRT()
{
  updateEncoder(3, ROTARY_RT_A, ROTARY_RT_B);
}
void updateEncoderRM()
{
  updateEncoder(4, ROTARY_RM_A, ROTARY_RM_B);
}
void updateEncoderRB()
{
  updateEncoder(5, ROTARY_RB_A, ROTARY_RB_B);
}

void updateEncoder(int encoderIndex, int pinA, int pinB)
{
  int MSB = digitalRead(pinA); // Most Significant Bit
  int LSB = digitalRead(pinB); // Least Significant Bit

  int encoded = (MSB << 1) | LSB;                       // Convert the 2 pin values to a single number
  int sum = (lastEncoded[encoderIndex] << 2) | encoded; // Combine with last encoded value

  sprintf(encoderDebug, "encoderIndex: %d, Readout: %d", encoderIndex, sum);
  Serial.println(encoderDebug);
  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011)
    encoderValues[encoderIndex]++;
  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000)
    encoderValues[encoderIndex]--;

  lastEncoded[encoderIndex] = encoded; // Store for next time
}

void actuators(const char *value)
{
  Serial.println("actuators Function");
  Serial.print("actuatorValue: ");
  Serial.println(value);

  if (strcmp(value, "up") == 0)
  {
    digitalWrite(ACTUATORS_UP, HIGH);
    digitalWrite(ACTUATORS_DN, LOW);
    Serial.println("Actuators UP");
  }
  else if (strcmp(value, "down") == 0)
  {
    digitalWrite(ACTUATORS_UP, LOW);
    digitalWrite(ACTUATORS_DN, HIGH);
    Serial.println("Actuators DOWN");
  }
  else if (strcmp(value, "stop") == 0)
  {
    digitalWrite(ACTUATORS_UP, LOW);
    digitalWrite(ACTUATORS_DN, LOW);
    Serial.println("Actuators STOP");
  }
  else
  {
    Serial.println("Invalid Actuator Command - use 'up', 'down', or 'stop'");
  }
}
